# 25 - 媒体类型检测需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 24-媒体管道基础需求
> **后续文档**: 26-图片处理需求

---

## 1. 需求概述

### 1.1 目标描述

实现**准确的媒体类型检测机制**，通过魔数、Header、扩展名等多种方式识别文件真实类型。

**核心目标:**
- **魔数检测**: 读取文件头识别类型
- **多源融合**: 结合 Header、扩展名、内容分析
- **格式验证**: 验证文件格式完整性

---

## 2. 检测策略

### 2.1 三级检测

```typescript
// 1. 魔数检测(最可靠)
const sniffed = await fileTypeFromBuffer(buffer);

// 2. HTTP Header
const headerMime = response.headers.get('content-type');

// 3. 文件扩展名
const ext = path.extname(filename);
const mime = MIME_BY_EXT[ext];
```

### 2.2 常见魔数

| 类型 | 魔数 | 说明 |
|------|------|------|
| JPEG | `FF D8 FF` | JPEG 图片 |
| PNG | `89 50 4E 47` | PNG 图片 |
| GIF | `47 49 46 38` | GIF 图片 |
| WebP | `52 49 46 46 ... 57 45 42 50` | WebP 图片 |
| PDF | `25 50 44 46` | PDF 文档 |
| ZIP | `50 4B 03 04` | ZIP 压缩包 |
| MP3 | `49 44 33` 或 `FF FB` | MP3 音频 |

---

## 3. 实现

```typescript
import { fileTypeFromBuffer } from 'file-type';

export async function detectMime(opts: {
  buffer?: Buffer;
  headerMime?: string | null;
  filePath?: string;
}): Promise<string | undefined> {
  // 魔数检测
  if (opts.buffer) {
    const type = await fileTypeFromBuffer(opts.buffer);
    if (type && !isGenericMime(type.mime)) {
      return type.mime;
    }
  }

  // Header MIME
  const headerMime = normalizeHeaderMime(opts.headerMime);
  if (headerMime && !isGenericMime(headerMime)) {
    return headerMime;
  }

  // 扩展名
  const ext = getFileExtension(opts.filePath);
  if (ext) {
    const mime = MIME_BY_EXT[ext];
    if (mime) return mime;
  }

  return undefined;
}
```

---

**文档完成** ✅
