# 03 - 依赖注入系统需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 01-配置系统需求, 02-CLI命令框架需求
> **后续文档**: 04-Gateway基础架构需求

---

## 1. 需求概述

### 1.1 目标描述

实现一个**轻量级、类型安全**的依赖注入系统,用于管理服务间的依赖关系,提高代码的可测试性和模块化程度。该系统采用工厂函数模式,避免复杂的 DI 容器,保持简单和可控。

**核心目标:**
- **松耦合**: 模块间通过接口依赖,而非具体实现
- **可测试性**: 测试时可轻松替换依赖为 Mock 对象
- **显式依赖**: 所有依赖通过参数显式传递,避免隐式的全局状态
- **类型安全**: 利用 TypeScript 类型系统保证依赖的正确性

### 1.2 业务场景

#### 场景 1: 命令执行需要多个服务
**问题**: `agent` 命令需要发送消息到不同渠道,依赖多个发送函数。

**传统方式(紧耦合)**:
```typescript
import { sendMessageWhatsApp } from '../channels/whatsapp/send.js';
import { sendMessageTelegram } from '../telegram/send.js';

async function agentCommand(options) {
  // 直接依赖具体实现
  await sendMessageWhatsApp(...);
  await sendMessageTelegram(...);
}
```

**问题**:
- 测试困难,需要 mock 文件导入
- 修改依赖时需要改动多处代码
- 无法在运行时替换实现

**依赖注入方式(松耦合)**:
```typescript
interface AgentDeps {
  sendWhatsApp: typeof sendMessageWhatsApp;
  sendTelegram: typeof sendMessageTelegram;
}

async function agentCommand(options, deps: AgentDeps) {
  // 通过依赖参数使用
  await deps.sendWhatsApp(...);
  await deps.sendTelegram(...);
}

// 使用时注入依赖
const deps = createDefaultDeps();
await agentCommand(options, deps);
```

**优点**:
- 测试时可轻松替换为 Mock
- 依赖关系显式,易于理解
- 支持运行时替换实现

#### 场景 2: 单元测试需要 Mock 依赖
**需求**: 测试 `agentCommand` 时,不应真正发送消息到渠道。

**实现**:
```typescript
// 测试代码
import { describe, it, expect, vi } from 'vitest';

describe('agentCommand', () => {
  it('should send message to WhatsApp', async () => {
    // 创建 Mock 依赖
    const mockDeps = {
      sendWhatsApp: vi.fn(),
      sendTelegram: vi.fn(),
    };

    // 执行命令
    await agentCommand({ message: 'test' }, mockDeps);

    // 验证调用
    expect(mockDeps.sendWhatsApp).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'test' })
    );
  });
});
```

#### 场景 3: 集成测试需要真实依赖
**需求**: 集成测试时使用真实的服务实现。

**实现**:
```typescript
// 集成测试
describe('agentCommand integration', () => {
  it('should work with real services', async () => {
    // 使用真实依赖
    const deps = createDefaultDeps();

    // 执行完整流程
    await agentCommand({ message: 'test' }, deps);

    // 验证真实效果
    // ...
  });
});
```

### 1.3 用户价值

- **开发效率提升**: 清晰的依赖关系,易于理解和维护
- **测试质量提升**: 可测试性强,降低测试复杂度
- **代码质量提升**: 强制模块化,避免紧耦合

---

## 2. 核心概念

### 2.1 依赖注入(Dependency Injection)

**定义**: 依赖注入是一种设计模式,通过外部传入依赖,而非在模块内部创建依赖。

**三种注入方式**:

#### 方式 1: 构造函数注入
```typescript
class AgentService {
  constructor(private deps: AgentDeps) {}

  async run() {
    await this.deps.sendWhatsApp(...);
  }
}

// 使用
const service = new AgentService(createDefaultDeps());
```

#### 方式 2: 参数注入(Moltbot 采用)
```typescript
async function agentCommand(options: Options, deps: AgentDeps) {
  await deps.sendWhatsApp(...);
}

// 使用
await agentCommand(options, createDefaultDeps());
```

#### 方式 3: 属性注入
```typescript
class AgentService {
  deps!: AgentDeps;

  async run() {
    await this.deps.sendWhatsApp(...);
  }
}

// 使用
const service = new AgentService();
service.deps = createDefaultDeps();
```

**Moltbot 选择参数注入的原因**:
- 函数式风格,无需类
- 依赖显式,一目了然
- TypeScript 类型检查自然支持

### 2.2 依赖容器(Dependency Container)

**定义**: 依赖容器是持有所有依赖实例的对象。

**Moltbot 的依赖容器**:
```typescript
interface CliDeps {
  sendMessageWhatsApp: typeof sendMessageWhatsApp;
  sendMessageTelegram: typeof sendMessageTelegram;
  sendMessageDiscord: typeof sendMessageDiscord;
  sendMessageSlack: typeof sendMessageSlack;
  sendMessageSignal: typeof sendMessageSignal;
  sendMessageIMessage: typeof sendMessageIMessage;
}
```

**特点**:
- 简单的对象,无复杂逻辑
- 所有依赖都是函数引用
- 类型由 TypeScript 保证

### 2.3 工厂函数(Factory Function)

**定义**: 工厂函数负责创建依赖容器,提供默认实现。

**实现**:
```typescript
export function createDefaultDeps(): CliDeps {
  return {
    sendMessageWhatsApp,
    sendMessageTelegram,
    sendMessageDiscord,
    sendMessageSlack,
    sendMessageSignal,
    sendMessageIMessage,
  };
}
```

**用途**:
- 生产环境使用默认实现
- 测试环境创建 Mock 实现
- 支持部分替换依赖

### 2.4 依赖适配器(Dependency Adapter)

**定义**: 将一种依赖格式转换为另一种格式的函数。

**示例(CliDeps → OutboundSendDeps)**:
```typescript
// CLI 依赖接口
interface CliDeps {
  sendMessageWhatsApp: typeof sendMessageWhatsApp;
  // ...
}

// Outbound 依赖接口
interface OutboundSendDeps {
  sendWhatsApp: typeof sendMessageWhatsApp;
  // ...
}

// 适配器函数
export function createOutboundSendDeps(deps: CliDeps): OutboundSendDeps {
  return {
    sendWhatsApp: deps.sendMessageWhatsApp,
    sendTelegram: deps.sendMessageTelegram,
    sendDiscord: deps.sendMessageDiscord,
    sendSlack: deps.sendMessageSlack,
    sendSignal: deps.sendMessageSignal,
    sendIMessage: deps.sendMessageIMessage,
  };
}
```

**用途**:
- 不同模块使用不同的依赖接口
- 避免依赖接口变化影响所有模块
- 提供统一的依赖获取入口

---

## 3. 功能需求

### 3.1 核心功能列表

#### P0 功能(必须实现)

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F01** | 依赖容器定义 | 定义 CliDeps 接口 |
| **F02** | 工厂函数 | 实现 createDefaultDeps() |
| **F03** | 依赖传递 | 在命令中传递依赖容器 |
| **F04** | 类型定义导出 | 导出依赖接口供其他模块使用 |

#### P1 功能(重要)

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F05** | 依赖适配器 | 实现 createOutboundSendDeps() |
| **F06** | 部分依赖创建 | 支持创建部分依赖的容器 |
| **F07** | 依赖合并 | 支持合并多个依赖容器 |

#### P2 功能(可选)

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F08** | 依赖生命周期管理 | 管理单例、瞬态等生命周期 |
| **F09** | 依赖验证 | 验证依赖容器的完整性 |

### 3.2 依赖类型

#### 类型 1: 消息发送依赖
**用途**: 发送消息到各个渠道。

**依赖**:
- `sendMessageWhatsApp`
- `sendMessageTelegram`
- `sendMessageDiscord`
- `sendMessageSlack`
- `sendMessageSignal`
- `sendMessageIMessage`

#### 类型 2: 配置依赖
**用途**: 加载和保存配置。

**依赖**:
- `loadConfig`
- `writeConfigFile`

#### 类型 3: 会话依赖
**用途**: 管理会话和历史。

**依赖**:
- `loadSessionStore`
- `saveSessionStore`
- `updateSessionEntry`

#### 类型 4: 其他工具依赖
**用途**: 各种工具函数。

**依赖**:
- `runExec`
- `promptYesNo`
- `waitForever`

---

## 4. 非功能需求

### 4.1 性能要求

| 指标 | 要求 | 说明 |
|------|------|------|
| **依赖创建时间** | < 1ms | createDefaultDeps() 应该非常快 |
| **内存开销** | 最小化 | 依赖容器只持有函数引用,不复制数据 |

### 4.2 可测试性要求

| 要求 | 说明 |
|------|------|
| **Mock 友好** | 所有依赖都可以轻松替换为 Mock |
| **类型安全** | Mock 对象必须符合依赖接口的类型 |
| **隔离性** | 测试间互不影响,每个测试独立创建依赖 |

### 4.3 可维护性要求

| 要求 | 说明 |
|------|------|
| **显式依赖** | 所有依赖通过参数传递,避免隐式依赖 |
| **单一职责** | 依赖容器只负责持有依赖,不包含业务逻辑 |
| **文档完整** | 每个依赖都有清晰的类型定义和注释 |

---

## 5. 架构设计

### 5.1 技术选型

| 技术 | 用途 | 选型理由 |
|------|------|---------|
| **TypeScript 接口** | 定义依赖契约 | 类型安全、编译时检查 |
| **工厂函数** | 创建依赖容器 | 简单、灵活、无运行时开销 |
| **函数引用** | 持有依赖 | 轻量级、无状态 |

### 5.2 设计模式

#### 模式 1: 工厂模式(Factory Pattern)

**用途**: 创建依赖容器。

**实现**:
```typescript
export function createDefaultDeps(): CliDeps {
  return {
    sendMessageWhatsApp,
    sendMessageTelegram,
    sendMessageDiscord,
    sendMessageSlack,
    sendMessageSignal,
    sendMessageIMessage,
  };
}
```

**优点**:
- 集中管理依赖创建逻辑
- 易于测试(可替换工厂函数)
- 支持延迟初始化

#### 模式 2: 依赖注入模式(Dependency Injection Pattern)

**用途**: 将依赖传递给需要的模块。

**实现**:
```typescript
// 定义依赖接口
interface AgentDeps {
  sendWhatsApp: SendFunction;
  sendTelegram: SendFunction;
}

// 接受依赖参数的函数
async function agentCommand(
  options: AgentOptions,
  deps: AgentDeps
): Promise<void> {
  await deps.sendWhatsApp(...);
}

// 调用时注入依赖
const deps = createDefaultDeps();
await agentCommand(options, deps);
```

#### 模式 3: 适配器模式(Adapter Pattern)

**用途**: 转换依赖接口格式。

**实现**:
```typescript
// 源接口
interface CliDeps {
  sendMessageWhatsApp: Function;
}

// 目标接口
interface OutboundDeps {
  sendWhatsApp: Function;
}

// 适配器
function createOutboundSendDeps(cli: CliDeps): OutboundDeps {
  return {
    sendWhatsApp: cli.sendMessageWhatsApp,
  };
}
```

### 5.3 模块结构

```
src/
├── cli/
│   └── deps.ts                  # CLI 依赖定义和工厂函数
├── infra/
│   └── outbound/
│       └── deliver.ts           # Outbound 依赖定义
├── commands/
│   ├── agent.ts                 # 使用依赖注入
│   ├── message.ts               # 使用依赖注入
│   └── *.ts                     # 其他命令
└── runtime.ts                   # 运行时依赖管理(可选)
```

### 5.4 接口定义

#### 接口 1: CliDeps

```typescript
/**
 * CLI 命令的依赖容器
 */
export interface CliDeps {
  /** 发送 WhatsApp 消息 */
  sendMessageWhatsApp: typeof sendMessageWhatsApp;

  /** 发送 Telegram 消息 */
  sendMessageTelegram: typeof sendMessageTelegram;

  /** 发送 Discord 消息 */
  sendMessageDiscord: typeof sendMessageDiscord;

  /** 发送 Slack 消息 */
  sendMessageSlack: typeof sendMessageSlack;

  /** 发送 Signal 消息 */
  sendMessageSignal: typeof sendMessageSignal;

  /** 发送 iMessage 消息 */
  sendMessageIMessage: typeof sendMessageIMessage;
}
```

#### 接口 2: OutboundSendDeps

```typescript
/**
 * Outbound 消息发送的依赖容器
 */
export interface OutboundSendDeps {
  /** 发送 WhatsApp 消息 */
  sendWhatsApp: typeof sendMessageWhatsApp;

  /** 发送 Telegram 消息 */
  sendTelegram: typeof sendMessageTelegram;

  /** 发送 Discord 消息 */
  sendDiscord: typeof sendMessageDiscord;

  /** 发送 Slack 消息 */
  sendSlack: typeof sendMessageSlack;

  /** 发送 Signal 消息 */
  sendSignal: typeof sendMessageSignal;

  /** 发送 iMessage 消息 */
  sendIMessage: typeof sendMessageIMessage;
}
```

### 5.5 数据流图

```
┌──────────────────────────────────────────────────────────┐
│              应用启动                                      │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│          1. 创建依赖容器                                   │
│          const deps = createDefaultDeps()                │
│          {                                               │
│            sendMessageWhatsApp: [Function],              │
│            sendMessageTelegram: [Function],              │
│            ...                                           │
│          }                                               │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│          2. 注入到命令                                     │
│          await agentCommand(options, deps)               │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│          3. 命令使用依赖                                   │
│          async function agentCommand(options, deps) {    │
│            await deps.sendWhatsApp(...)                  │
│          }                                               │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│          4. 依赖执行实际操作                               │
│          发送消息到 WhatsApp                               │
└──────────────────────────────────────────────────────────┘
```

---

## 6. 关键实现

### 6.1 实现步骤

#### 步骤 1: 定义依赖接口(deps.ts)

**目标**: 定义 CLI 依赖容器的接口。

**代码**:
```typescript
// src/cli/deps.ts
import { sendMessageWhatsApp } from '../channels/web/index.js';
import { sendMessageTelegram } from '../telegram/send.js';
import { sendMessageDiscord } from '../discord/send.js';
import { sendMessageSlack } from '../slack/send.js';
import { sendMessageSignal } from '../signal/send.js';
import { sendMessageIMessage } from '../imessage/send.js';

/**
 * CLI 依赖容器接口
 */
export interface CliDeps {
  sendMessageWhatsApp: typeof sendMessageWhatsApp;
  sendMessageTelegram: typeof sendMessageTelegram;
  sendMessageDiscord: typeof sendMessageDiscord;
  sendMessageSlack: typeof sendMessageSlack;
  sendMessageSignal: typeof sendMessageSignal;
  sendMessageIMessage: typeof sendMessageIMessage;
}
```

#### 步骤 2: 实现工厂函数

**目标**: 创建默认依赖容器。

**代码**:
```typescript
/**
 * 创建默认依赖容器(生产环境使用)
 */
export function createDefaultDeps(): CliDeps {
  return {
    sendMessageWhatsApp,
    sendMessageTelegram,
    sendMessageDiscord,
    sendMessageSlack,
    sendMessageSignal,
    sendMessageIMessage,
  };
}
```

#### 步骤 3: 实现依赖适配器

**目标**: 将 CliDeps 转换为 OutboundSendDeps。

**代码**:
```typescript
import type { OutboundSendDeps } from '../infra/outbound/deliver.js';

/**
 * 将 CLI 依赖转换为 Outbound 依赖
 */
export function createOutboundSendDeps(deps: CliDeps): OutboundSendDeps {
  return {
    sendWhatsApp: deps.sendMessageWhatsApp,
    sendTelegram: deps.sendMessageTelegram,
    sendDiscord: deps.sendMessageDiscord,
    sendSlack: deps.sendMessageSlack,
    sendSignal: deps.sendMessageSignal,
    sendIMessage: deps.sendMessageIMessage,
  };
}
```

#### 步骤 4: 在命令中使用依赖注入

**目标**: 修改命令函数,接受依赖参数。

**代码**:
```typescript
// src/commands/agent.ts
import type { CliDeps } from '../cli/deps.js';

interface AgentCommandOptions {
  message: string;
  // ...
}

/**
 * Agent 命令处理器
 */
export async function agentCommand(
  options: AgentCommandOptions,
  deps: CliDeps
): Promise<void> {
  // 使用依赖发送消息
  if (needSendToWhatsApp) {
    await deps.sendMessageWhatsApp({
      to: '...',
      text: options.message,
    });
  }

  if (needSendToTelegram) {
    await deps.sendMessageTelegram({
      chatId: '...',
      text: options.message,
    });
  }
}
```

#### 步骤 5: 在 CLI 注册中注入依赖

**目标**: 在命令注册时创建和传递依赖。

**代码**:
```typescript
// src/cli/program/register.agent.ts
import { createDefaultDeps } from '../deps.js';

export function registerAgentCommands(
  program: Command,
  ctx: ProgramContext
) {
  program
    .command('agent')
    .option('--message <text>')
    .action(async (options) => {
      // 创建依赖
      const deps = createDefaultDeps();

      // 注入依赖
      await agentCommand(options, deps);
    });
}
```

#### 步骤 6: 编写测试用例

**目标**: 使用 Mock 依赖测试命令。

**代码**:
```typescript
// src/commands/agent.test.ts
import { describe, it, expect, vi } from 'vitest';
import { agentCommand } from './agent.js';
import type { CliDeps } from '../cli/deps.js';

describe('agentCommand', () => {
  it('should send message to WhatsApp', async () => {
    // 创建 Mock 依赖
    const mockDeps: CliDeps = {
      sendMessageWhatsApp: vi.fn().mockResolvedValue(undefined),
      sendMessageTelegram: vi.fn(),
      sendMessageDiscord: vi.fn(),
      sendMessageSlack: vi.fn(),
      sendMessageSignal: vi.fn(),
      sendMessageIMessage: vi.fn(),
    };

    // 执行命令
    await agentCommand(
      { message: 'test', channel: 'whatsapp' },
      mockDeps
    );

    // 验证调用
    expect(mockDeps.sendMessageWhatsApp).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'test' })
    );
  });

  it('should not call other channels', async () => {
    const mockDeps: CliDeps = {
      sendMessageWhatsApp: vi.fn(),
      sendMessageTelegram: vi.fn(),
      sendMessageDiscord: vi.fn(),
      sendMessageSlack: vi.fn(),
      sendMessageSignal: vi.fn(),
      sendMessageIMessage: vi.fn(),
    };

    await agentCommand(
      { message: 'test', channel: 'whatsapp' },
      mockDeps
    );

    // 验证未调用其他渠道
    expect(mockDeps.sendMessageTelegram).not.toHaveBeenCalled();
    expect(mockDeps.sendMessageDiscord).not.toHaveBeenCalled();
  });
});
```

### 6.2 技术难点

#### 难点 1: 类型安全与灵活性的平衡

**问题**: 如何在保证类型安全的同时,支持部分替换依赖?

**解决方案**:
- 使用 TypeScript 的 `Partial` 工具类型
- 提供默认依赖合并函数

**实现**:
```typescript
/**
 * 创建部分依赖容器(测试时使用)
 */
export function createTestDeps(
  overrides: Partial<CliDeps> = {}
): CliDeps {
  const defaults = createDefaultDeps();
  return {
    ...defaults,
    ...overrides,
  };
}

// 使用
const deps = createTestDeps({
  sendMessageWhatsApp: vi.fn(), // 只 Mock WhatsApp
  // 其他依赖使用默认实现
});
```

#### 难点 2: 循环依赖

**问题**: 如果模块 A 依赖 B,B 又依赖 A,会导致循环依赖。

**解决方案**:
- 将依赖接口与实现分离
- 使用依赖注入打破循环

**示例**:
```typescript
// ❌ 循环依赖
// moduleA.ts
import { functionB } from './moduleB.js';
export function functionA() {
  functionB();
}

// moduleB.ts
import { functionA } from './moduleA.js';
export function functionB() {
  functionA();
}

// ✅ 使用依赖注入打破循环
// moduleA.ts
export function functionA(deps: { functionB: Function }) {
  deps.functionB();
}

// moduleB.ts
export function functionB(deps: { functionA: Function }) {
  deps.functionA();
}

// 在外部组装
const depsA = { functionB };
const depsB = { functionA };
```

#### 难点 3: Mock 对象的类型匹配

**问题**: 测试时创建的 Mock 对象可能与真实函数签名不一致。

**解决方案**:
- 使用 `vi.fn<Parameters, ReturnType>()` 指定类型
- 创建 Mock 工厂函数

**实现**:
```typescript
/**
 * 创建 Mock 依赖工厂函数
 */
export function createMockDeps(): CliDeps {
  return {
    sendMessageWhatsApp: vi.fn<
      Parameters<typeof sendMessageWhatsApp>,
      ReturnType<typeof sendMessageWhatsApp>
    >(),
    sendMessageTelegram: vi.fn<
      Parameters<typeof sendMessageTelegram>,
      ReturnType<typeof sendMessageTelegram>
    >(),
    // ...
  };
}

// 使用
const mockDeps = createMockDeps();
mockDeps.sendMessageWhatsApp.mockResolvedValue(undefined);
```

### 6.3 测试策略

#### 单元测试

**测试覆盖**:
- 工厂函数创建正确的依赖容器
- 依赖适配器正确转换接口
- 命令正确使用依赖

**示例**:
```typescript
describe('createDefaultDeps', () => {
  it('should create complete deps object', () => {
    const deps = createDefaultDeps();

    expect(deps.sendMessageWhatsApp).toBeTypeOf('function');
    expect(deps.sendMessageTelegram).toBeTypeOf('function');
    expect(deps.sendMessageDiscord).toBeTypeOf('function');
  });
});

describe('createOutboundSendDeps', () => {
  it('should convert CliDeps to OutboundSendDeps', () => {
    const cliDeps = createDefaultDeps();
    const outboundDeps = createOutboundSendDeps(cliDeps);

    expect(outboundDeps.sendWhatsApp).toBe(cliDeps.sendMessageWhatsApp);
    expect(outboundDeps.sendTelegram).toBe(cliDeps.sendMessageTelegram);
  });
});
```

### 6.4 参考代码位置

| 功能 | Moltbot 代码位置 |
|------|-----------------|
| 依赖定义 | `src/cli/deps.ts:9-16` |
| 工厂函数 | `src/cli/deps.ts:18-27` |
| 依赖适配器 | `src/cli/deps.ts:30-39` |
| 命令使用 | `src/commands/agent.ts` (在参数中接受 deps) |

---

## 7. 验收标准

### 7.1 功能验收

#### 验收项 1: 依赖容器创建

**测试步骤**:
1. 调用 `createDefaultDeps()`
2. 验证返回的对象包含所有必需的依赖

**通过标准**:
- 所有依赖字段存在
- 所有依赖都是函数类型

#### 验收项 2: 依赖注入

**测试步骤**:
1. 创建 Mock 依赖
2. 将 Mock 依赖传递给命令
3. 执行命令
4. 验证 Mock 依赖被调用

**通过标准**:
- 命令正确使用传入的依赖
- Mock 依赖被正确调用

#### 验收项 3: 依赖适配器

**测试步骤**:
1. 创建 CliDeps
2. 调用 `createOutboundSendDeps()`
3. 验证返回的 OutboundSendDeps

**通过标准**:
- 接口转换正确
- 函数引用一致

### 7.2 测试覆盖

**要求**: 测试覆盖率 ≥ 70%

**覆盖范围**:
- 工厂函数
- 依赖适配器
- 使用依赖注入的命令

---

## 8. 附录

### 8.1 依赖注入最佳实践

#### 实践 1: 接口优于实现
**说明**: 依赖接口应该定义契约,而非具体实现。

**示例**:
```typescript
// ✅ 好的实践
interface SendFunction {
  (params: SendParams): Promise<void>;
}

interface CliDeps {
  sendWhatsApp: SendFunction;
}

// ❌ 不好的实践
interface CliDeps {
  sendWhatsApp: ConcreteWhatsAppSender; // 依赖具体类
}
```

#### 实践 2: 显式依赖优于隐式依赖
**说明**: 所有依赖通过参数传递,避免全局变量。

**示例**:
```typescript
// ✅ 好的实践
async function command(options, deps: Deps) {
  await deps.send(...);
}

// ❌ 不好的实践
import { globalSender } from './global.js';
async function command(options) {
  await globalSender.send(...); // 隐式依赖全局变量
}
```

#### 实践 3: 最小化依赖
**说明**: 每个模块只依赖它真正需要的功能。

**示例**:
```typescript
// ✅ 好的实践
interface AgentDeps {
  sendWhatsApp: Function; // 只依赖 WhatsApp
}

// ❌ 不好的实践
interface AgentDeps extends CliDeps {
  // 依赖所有渠道,即使只用 WhatsApp
}
```

### 8.2 Mock 工具函数

```typescript
/**
 * 创建 Mock 依赖容器(所有依赖都是 Mock)
 */
export function createMockDeps(): CliDeps {
  return {
    sendMessageWhatsApp: vi.fn(),
    sendMessageTelegram: vi.fn(),
    sendMessageDiscord: vi.fn(),
    sendMessageSlack: vi.fn(),
    sendMessageSignal: vi.fn(),
    sendMessageIMessage: vi.fn(),
  };
}

/**
 * 创建部分 Mock 依赖容器
 */
export function createPartialMockDeps(
  mocks: Partial<CliDeps> = {}
): CliDeps {
  const defaults = createDefaultDeps();
  return {
    ...defaults,
    ...mocks,
  };
}
```

### 8.3 依赖生命周期

| 生命周期 | 说明 | 适用场景 |
|---------|------|---------|
| **瞬态(Transient)** | 每次使用时创建新实例 | 无状态的工具函数 |
| **单例(Singleton)** | 全局共享一个实例 | 配置、连接池等 |
| **作用域(Scoped)** | 在某个作用域内共享 | 请求级别的上下文 |

**Moltbot 的选择**:
- 所有依赖都是**瞬态**
- 依赖容器本身是**单例**(在 CLI 启动时创建一次)
- 无状态设计,简单可靠

---

**文档完成** ✅

下一步: 实现依赖注入系统代码,并编写单元测试。
