# 01 - 配置系统需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 无（基础模块）
> **后续文档**: 02-CLI命令框架需求, 03-依赖注入系统需求

---

## 1. 需求概述

### 1.1 目标描述

实现一个**集中式、类型安全、多层级**的配置管理系统,作为整个 AI 助手系统的核心配置基础设施。该系统需要支持复杂的配置场景,包括多 Agent、多渠道、多模型的配置管理,并提供灵活的配置加载、验证、持久化和热重载能力。

**核心目标:**
- **统一配置入口**: 所有系统配置通过单一配置文件管理
- **类型安全**: 通过 TypeScript 类型和 Zod Schema 提供强类型保障
- **多层级覆盖**: 支持默认值、配置文件、环境变量的层级覆盖
- **配置热重载**: 支持配置文件变化时的自动重载(部分或完全)
- **配置迁移**: 支持旧版本配置的自动检测和迁移

### 1.2 业务场景

#### 场景 1: 初次安装和配置
**用户操作**: 用户首次安装系统,需要配置 AI 模型、消息渠道等基本信息。

**系统行为**:
1. 系统检测配置文件不存在
2. 使用默认配置启动,允许用户通过 CLI 命令或 UI 界面配置
3. 用户配置后,生成配置文件到 `~/.clawdbot/config.json5`
4. 配置自动验证,确保必填字段完整

#### 场景 2: 多环境配置管理
**用户操作**: 用户在开发、测试、生产环境使用不同的配置。

**系统行为**:
1. 支持通过环境变量覆盖配置文件中的敏感信息(如 API Key)
2. 支持 `${VAR_NAME}` 语法引用环境变量
3. 支持 `--profile` 参数加载不同的配置文件

#### 场景 3: 配置错误诊断
**用户操作**: 用户修改配置文件后,配置格式或值不正确。

**系统行为**:
1. 配置加载时自动验证
2. 输出详细的错误信息,包括错误路径和具体问题
3. 如果配置无效,回退到默认配置,避免系统完全不可用

#### 场景 4: 配置热重载
**用户操作**: 用户在系统运行时修改配置文件。

**系统行为**:
1. 监听配置文件变化
2. 检测到变化后重新加载配置
3. 根据配置的类型,决定是否需要重启 Gateway 或只是热更新

### 1.3 用户价值

- **降低配置复杂度**: 统一的配置结构,用户只需要学习一种配置方式
- **提高配置安全性**: 敏感信息通过环境变量管理,避免明文存储
- **快速诊断问题**: 详细的错误提示和配置验证,快速定位配置问题
- **灵活的配置管理**: 支持多种配置方式(文件、环境变量、CLI 参数),适应不同场景

---

## 2. 核心概念

### 2.1 配置文件

**定义**: 配置文件是系统配置的主要来源,采用 **JSON5** 格式,支持注释和更灵活的语法。

**默认位置**:
- 主配置文件: `~/.clawdbot/config.json5`
- 可通过环境变量 `CLAWDBOT_CONFIG_PATH` 覆盖
- 可通过环境变量 `CLAWDBOT_STATE_DIR` 覆盖整个状态目录

**JSON5 格式特点**:
- 支持单行注释 `//` 和多行注释 `/* */`
- 支持尾随逗号
- 支持单引号字符串
- 支持十六进制数字

**示例**:
```json5
{
  // AI 模型配置
  models: {
    default: "anthropic/claude-sonnet-4-5",
    providers: {
      anthropic: {
        apiKey: "${ANTHROPIC_API_KEY}" // 从环境变量读取
      }
    }
  },

  // Agent 配置
  agents: {
    list: [
      {
        id: "main",
        name: "主助手",
        default: true,
        provider: "anthropic",
        model: "sonnet"
      }
    ]
  },

  // 消息渠道配置
  channels: {
    whatsapp: {
      enabled: true,
      accountId: "default"
    }
  }
}
```

### 2.2 配置层级和优先级

配置值的解析按照以下优先级(从高到低):

```
1. 运行时覆盖(Runtime Overrides) - 通过 CLI 参数传入
2. 环境变量(Environment Variables) - ${VAR_NAME} 语法
3. 配置文件(Config File) - config.json5
4. 默认值(Defaults) - 代码中定义的默认值
```

**解析流程**:
```
加载配置文件(JSON5)
  → 解析 $include 指令(配置包含)
  → 应用 config.env 到 process.env
  → 替换环境变量引用(${VAR})
  → Schema 验证(Zod)
  → 应用默认值
  → 路径规范化
  → 应用运行时覆盖
  → 最终配置
```

### 2.3 配置模块化

配置按照功能模块划分为多个子配置,每个子配置有独立的 TypeScript 类型定义:

| 模块 | 类型文件 | 说明 |
|------|---------|------|
| **基础配置** | `types.base.ts` | 元数据、日志、更新等 |
| **Agent 配置** | `types.agents.ts` | Agent 列表、默认值、绑定 |
| **模型配置** | `types.models.ts` | AI 模型、提供商、认证 |
| **渠道配置** | `types.channels.ts` | 消息渠道配置(WhatsApp、Telegram等) |
| **工具配置** | `types.tools.ts` | 工具系统配置(Browser、Cron等) |
| **Gateway 配置** | `types.gateway.ts` | Gateway 服务器、端口、认证 |
| **会话配置** | `types.messages.ts` | 会话管理、消息策略 |
| **认证配置** | `types.auth.ts` | 认证配置文件、OAuth等 |

### 2.4 环境变量替换

**语法**: `${VAR_NAME}`

**规则**:
- 只匹配大写字母和下划线组成的环境变量: `[A-Z_][A-Z0-9_]*`
- 如果环境变量未定义或为空,抛出 `MissingEnvVarError`
- 转义语法: `$${VAR}` 输出字面量 `${VAR}`

**示例**:
```json5
{
  models: {
    providers: {
      anthropic: {
        apiKey: "${ANTHROPIC_API_KEY}"  // 必须存在
      },
      openai: {
        apiKey: "${OPENAI_API_KEY}"     // 必须存在
      }
    }
  }
}
```

### 2.5 配置包含($include)

**语法**: `$include: "path/to/file.json5"`

**用途**: 将配置拆分到多个文件,便于管理和复用。

**示例**:
```json5
// config.json5
{
  agents: {
    $include: "./agents-config.json5"
  },
  channels: {
    $include: "./channels-config.json5"
  }
}
```

**规则**:
- 相对路径基于当前配置文件所在目录
- 支持嵌套包含
- 检测循环包含,避免死循环

### 2.6 配置快照(Snapshot)

**定义**: 配置快照是配置文件的完整读取结果,包含原始内容、解析结果、验证状态等元数据。

**字段**:
```typescript
interface ConfigFileSnapshot {
  path: string;              // 配置文件路径
  exists: boolean;           // 文件是否存在
  raw: string | null;        // 原始文本内容
  parsed: unknown;           // JSON5 解析结果
  valid: boolean;            // 是否验证通过
  config: MoltbotConfig;     // 最终配置对象
  hash: string;              // 内容哈希(用于检测变化)
  issues: ConfigIssue[];     // 验证错误列表
  warnings: ConfigIssue[];   // 验证警告列表
  legacyIssues: LegacyConfigIssue[]; // 旧配置迁移问题
}
```

**用途**:
- 配置文件编辑器显示验证结果
- 热重载时检测配置是否变化
- 配置诊断和问题排查

### 2.7 配置缓存

**目的**: 减少重复的配置文件读取和解析开销。

**机制**:
- 默认缓存 200ms
- 缓存键: 配置文件路径
- 缓存失效: 超过缓存时间,或配置文件被修改

**环境变量控制**:
- `CLAWDBOT_CONFIG_CACHE_MS`: 缓存时间(毫秒)
- `CLAWDBOT_DISABLE_CONFIG_CACHE`: 禁用缓存

---

## 3. 功能需求

### 3.1 核心功能列表

#### P0 功能(必须实现)

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F01** | 配置文件加载 | 从文件系统加载 JSON5 配置文件 |
| **F02** | 配置 Schema 验证 | 使用 Zod Schema 验证配置的正确性 |
| **F03** | 环境变量替换 | 支持 `${VAR}` 语法引用环境变量 |
| **F04** | 默认值应用 | 为未配置的字段应用默认值 |
| **F05** | 配置文件写入 | 保存配置到文件系统 |
| **F06** | 配置错误处理 | 详细的错误信息和错误恢复 |
| **F07** | 类型定义导出 | 导出 TypeScript 类型供其他模块使用 |

#### P1 功能(重要)

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F08** | 配置包含($include) | 支持将配置拆分到多个文件 |
| **F09** | 配置快照读取 | 读取配置的完整快照(包含验证结果) |
| **F10** | 配置文件备份 | 写入配置前自动备份(最多保留 5 个) |
| **F11** | 配置路径规范化 | 自动将相对路径转换为绝对路径 |
| **F12** | Shell 环境变量回退 | 从 Shell 环境加载常见的环境变量 |

#### P2 功能(可选)

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F13** | 配置版本标记 | 记录配置最后修改的版本和时间 |
| **F14** | 配置迁移检测 | 检测旧版本配置并给出迁移建议 |
| **F15** | 配置缓存 | 缓存配置对象,减少重复加载 |

### 3.2 用户交互流程

#### 流程 1: 首次启动(无配置文件)

```
用户启动系统
  ↓
检测配置文件不存在
  ↓
加载默认配置(空对象)
  ↓
应用默认值(agents、models 等)
  ↓
系统以默认配置启动
  ↓
用户通过 CLI 或 UI 配置
  ↓
保存配置到 config.json5
  ↓
系统重新加载配置
```

#### 流程 2: 正常启动(配置文件存在)

```
用户启动系统
  ↓
加载配置文件(config.json5)
  ↓
解析 JSON5
  ↓
解析 $include 指令
  ↓
替换环境变量(${VAR})
  ↓
Schema 验证(Zod)
  ├─ 验证失败 → 输出错误 → 使用默认配置
  └─ 验证成功 → 应用默认值 → 路径规范化
  ↓
系统以配置启动
```

#### 流程 3: 配置修改和保存

```
用户修改配置(通过 CLI 或 UI)
  ↓
构建新的配置对象
  ↓
Schema 验证
  ├─ 验证失败 → 返回错误 → 不保存
  └─ 验证成功 → 继续
  ↓
备份当前配置文件
  ↓
写入新配置到临时文件
  ↓
原子重命名替换原配置文件
  ↓
清除配置缓存
  ↓
保存成功
```

---

## 4. 非功能需求

### 4.1 性能要求

| 指标 | 要求 | 测量方法 |
|------|------|---------|
| **配置加载时间** | < 100ms(无缓存) | 测量 `loadConfig()` 执行时间 |
| **配置验证时间** | < 50ms | 测量 Zod Schema 验证时间 |
| **配置写入时间** | < 200ms | 测量 `writeConfigFile()` 执行时间 |
| **缓存命中率** | > 90%(正常运行) | 统计缓存命中次数 |

### 4.2 可靠性要求

| 要求 | 说明 |
|------|------|
| **原子性写入** | 配置写入必须是原子操作,避免写入一半时崩溃导致配置损坏 |
| **自动备份** | 每次写入前自动备份,保留最近 5 个版本 |
| **错误恢复** | 配置加载失败时,回退到默认配置,系统不应完全不可用 |
| **循环检测** | 检测配置包含的循环引用,避免死循环 |

### 4.3 安全性要求

| 要求 | 说明 |
|------|------|
| **文件权限** | 配置文件权限设置为 `0600`(仅所有者可读写) |
| **敏感信息保护** | 敏感信息(API Key)通过环境变量管理,不明文存储 |
| **路径注入防护** | 验证配置包含的路径,防止路径遍历攻击 |

### 4.4 可扩展性要求

| 要求 | 说明 |
|------|------|
| **模块化配置** | 配置按照功能模块划分,每个模块独立的类型定义 |
| **Schema 可扩展** | 支持插件动态扩展配置 Schema |
| **自定义验证** | 支持自定义验证规则(如跨字段验证) |

---

## 5. 架构设计

### 5.1 技术选型

| 技术 | 版本 | 用途 | 选型理由 |
|------|------|------|---------|
| **TypeScript** | 5.x | 类型系统 | 提供强类型保障,编译时检查 |
| **JSON5** | 2.x | 配置文件格式 | 支持注释和更灵活的语法 |
| **Zod** | 3.x | Schema 验证 | 运行时类型验证,错误信息友好 |
| **Node.js fs** | 内置 | 文件系统操作 | 原生支持,性能好 |
| **crypto** | 内置 | 哈希计算 | 用于配置变化检测 |

### 5.2 设计模式

#### 模式 1: 工厂模式(Factory Pattern)

**用途**: 创建配置 IO 对象,支持依赖注入测试。

**实现**:
```typescript
function createConfigIO(overrides: ConfigIoDeps = {}) {
  const deps = normalizeDeps(overrides);

  return {
    configPath: resolveConfigPath(...),
    loadConfig: () => { /* 实现 */ },
    readConfigFileSnapshot: async () => { /* 实现 */ },
    writeConfigFile: async (cfg) => { /* 实现 */ }
  };
}
```

**优点**:
- 依赖注入,便于单元测试
- 支持运行时替换文件系统实现

#### 模式 2: 管道模式(Pipeline Pattern)

**用途**: 配置加载流程由多个独立的步骤组成,按顺序执行。

**实现**:
```typescript
function loadConfig(): MoltbotConfig {
  const raw = readFile(configPath);            // 1. 读取文件
  const parsed = parseJSON5(raw);              // 2. 解析 JSON5
  const included = resolveIncludes(parsed);    // 3. 解析 $include
  const substituted = resolveEnvVars(included); // 4. 替换环境变量
  const validated = validateSchema(substituted); // 5. Schema 验证
  const defaulted = applyDefaults(validated);  // 6. 应用默认值
  const normalized = normalizePaths(defaulted); // 7. 路径规范化
  return defaulted;
}
```

**优点**:
- 每个步骤职责单一,易于测试
- 步骤可独立优化或替换

#### 模式 3: 缓存模式(Cache Pattern)

**用途**: 减少重复的配置文件读取和解析。

**实现**:
```typescript
let configCache: {
  configPath: string;
  expiresAt: number;
  config: MoltbotConfig;
} | null = null;

function loadConfig(): MoltbotConfig {
  const now = Date.now();
  if (configCache && configCache.expiresAt > now) {
    return configCache.config; // 缓存命中
  }

  const config = doLoadConfig(); // 缓存未命中,重新加载
  configCache = {
    configPath,
    expiresAt: now + CACHE_MS,
    config
  };
  return config;
}
```

### 5.3 模块结构

```
src/config/
├── io.ts                    # 配置 I/O(加载、保存)
├── types.ts                 # 类型导出入口
├── types.base.ts            # 基础类型
├── types.agents.ts          # Agent 配置类型
├── types.models.ts          # 模型配置类型
├── types.channels.ts        # 渠道配置类型
├── types.gateway.ts         # Gateway 配置类型
├── types.tools.ts           # 工具配置类型
├── types.auth.ts            # 认证配置类型
├── zod-schema.ts            # Zod Schema 定义
├── validation.ts            # 配置验证
├── defaults.ts              # 默认值应用
├── env-substitution.ts      # 环境变量替换
├── includes.ts              # 配置包含解析
├── normalize-paths.ts       # 路径规范化
├── paths.ts                 # 路径解析工具
├── legacy.ts                # 旧配置迁移检测
├── agent-dirs.ts            # Agent 目录检查
└── runtime-overrides.ts     # 运行时覆盖
```

### 5.4 接口定义

#### 接口 1: ConfigIO

```typescript
interface ConfigIO {
  /** 配置文件路径 */
  configPath: string;

  /** 加载配置 */
  loadConfig(): MoltbotConfig;

  /** 读取配置文件快照 */
  readConfigFileSnapshot(): Promise<ConfigFileSnapshot>;

  /** 写入配置文件 */
  writeConfigFile(cfg: MoltbotConfig): Promise<void>;
}
```

#### 接口 2: MoltbotConfig

```typescript
interface MoltbotConfig {
  meta?: {
    lastTouchedVersion?: string;   // 最后修改的版本
    lastTouchedAt?: string;        // 最后修改时间
  };

  env?: {
    shellEnv?: {
      enabled?: boolean;           // 是否从 Shell 加载环境变量
      timeoutMs?: number;          // 超时时间
    };
    vars?: Record<string, string>; // 自定义环境变量
  };

  logging?: LoggingConfig;         // 日志配置
  models?: ModelsConfig;           // 模型配置
  agents?: AgentsConfig;           // Agent 配置
  channels?: ChannelsConfig;       // 渠道配置
  gateway?: GatewayConfig;         // Gateway 配置
  tools?: ToolsConfig;             // 工具配置
  session?: SessionConfig;         // 会话配置
  // ... 其他模块配置
}
```

#### 接口 3: ConfigFileSnapshot

```typescript
interface ConfigFileSnapshot {
  path: string;                    // 配置文件路径
  exists: boolean;                 // 文件是否存在
  raw: string | null;              // 原始文本
  parsed: unknown;                 // JSON5 解析结果
  valid: boolean;                  // 是否验证通过
  config: MoltbotConfig;           // 最终配置对象
  hash: string;                    // 内容哈希
  issues: ConfigIssue[];           // 验证错误
  warnings: ConfigIssue[];         // 验证警告
  legacyIssues: LegacyConfigIssue[]; // 迁移问题
}
```

### 5.5 数据流图

```
┌─────────────────────────────────────────────────────────┐
│               用户/系统调用 loadConfig()                  │
└──────────────────────┬──────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────┐
│          1. 检查配置缓存(Cache)                          │
│          configCache?.expiresAt > now?                   │
└────────────┬──────────────────────────┬─────────────────┘
            YES                        NO
             │                          │
             ▼                          ▼
        返回缓存配置          ┌──────────────────────┐
                            │  2. 读取配置文件       │
                            │  fs.readFileSync()    │
                            └──────────┬────────────┘
                                       │
                                       ▼
                            ┌──────────────────────┐
                            │  3. 解析 JSON5        │
                            │  JSON5.parse()       │
                            └──────────┬────────────┘
                                       │
                                       ▼
                            ┌──────────────────────┐
                            │  4. 解析 $include     │
                            │  resolveIncludes()   │
                            └──────────┬────────────┘
                                       │
                                       ▼
                            ┌──────────────────────┐
                            │ 5. 应用 config.env    │
                            │ applyConfigEnv()     │
                            └──────────┬────────────┘
                                       │
                                       ▼
                            ┌──────────────────────┐
                            │ 6. 替换环境变量       │
                            │ resolveEnvVars()     │
                            └──────────┬────────────┘
                                       │
                                       ▼
                            ┌──────────────────────┐
                            │ 7. Schema 验证        │
                            │ validateSchema()     │
                            └──────────┬────────────┘
                                       │
                              ┌────────┴────────┐
                              │                 │
                           验证失败          验证成功
                              │                 │
                              ▼                 ▼
                        返回空配置    ┌──────────────────────┐
                        (默认值)      │ 8. 应用默认值         │
                                     │ applyDefaults()      │
                                     └──────────┬────────────┘
                                                │
                                                ▼
                                     ┌──────────────────────┐
                                     │ 9. 路径规范化         │
                                     │ normalizePaths()     │
                                     └──────────┬────────────┘
                                                │
                                                ▼
                                     ┌──────────────────────┐
                                     │ 10. 运行时覆盖        │
                                     │ applyOverrides()     │
                                     └──────────┬────────────┘
                                                │
                                                ▼
                                     ┌──────────────────────┐
                                     │ 11. 更新缓存          │
                                     │ configCache = ...    │
                                     └──────────┬────────────┘
                                                │
                                                ▼
                                          返回最终配置
```

### 5.6 依赖关系

```
config/io.ts (主入口)
  ├─ depends on → types.ts (类型定义)
  ├─ depends on → validation.ts (验证)
  ├─ depends on → defaults.ts (默认值)
  ├─ depends on → env-substitution.ts (环境变量)
  ├─ depends on → includes.ts (配置包含)
  ├─ depends on → normalize-paths.ts (路径规范化)
  ├─ depends on → paths.ts (路径工具)
  └─ depends on → legacy.ts (迁移检测)

validation.ts
  ├─ depends on → zod-schema.ts (Zod Schema)
  └─ depends on → types.ts (类型定义)

defaults.ts
  └─ depends on → types.ts (类型定义)
```

---

## 6. 关键实现

### 6.1 实现步骤

#### 步骤 1: 定义配置类型(types.ts 系列)

**目标**: 定义完整的 TypeScript 类型,覆盖所有配置模块。

**关键点**:
- 模块化拆分,每个功能模块独立文件
- 类型尽量精确(使用字面量类型、联合类型)
- 添加详细的 JSDoc 注释

**伪代码**:
```typescript
// types.base.ts
export interface MoltbotConfig {
  meta?: MetaConfig;
  env?: EnvConfig;
  logging?: LoggingConfig;
  // ... 其他模块
}

export interface MetaConfig {
  lastTouchedVersion?: string;
  lastTouchedAt?: string;
}

export interface EnvConfig {
  shellEnv?: {
    enabled?: boolean;
    timeoutMs?: number;
  };
  vars?: Record<string, string>;
}

// types.ts (导出入口)
export * from './types.base.js';
export * from './types.agents.js';
export * from './types.models.js';
// ... 其他导出
```

#### 步骤 2: 定义 Zod Schema(zod-schema.ts)

**目标**: 为所有配置类型定义对应的 Zod Schema,用于运行时验证。

**关键点**:
- Schema 结构与 TypeScript 类型一致
- 使用 `.strict()` 防止额外字段
- 添加自定义验证规则(`.superRefine()`)
- 提供友好的错误信息

**伪代码**:
```typescript
import { z } from 'zod';

export const MetaSchema = z.object({
  lastTouchedVersion: z.string().optional(),
  lastTouchedAt: z.string().optional()
}).strict().optional();

export const EnvSchema = z.object({
  shellEnv: z.object({
    enabled: z.boolean().optional(),
    timeoutMs: z.number().int().nonnegative().optional()
  }).strict().optional(),
  vars: z.record(z.string(), z.string()).optional()
}).strict().optional();

export const MoltbotSchema = z.object({
  meta: MetaSchema,
  env: EnvSchema,
  // ... 其他字段
}).strict();
```

#### 步骤 3: 实现环境变量替换(env-substitution.ts)

**目标**: 递归遍历配置对象,替换所有 `${VAR}` 为环境变量值。

**关键点**:
- 只匹配大写字母和下划线的环境变量
- 如果环境变量未定义,抛出清晰的错误
- 支持转义: `$${VAR}` → `${VAR}`

**伪代码**:
```typescript
export class MissingEnvVarError extends Error {
  constructor(
    public readonly varName: string,
    public readonly configPath: string
  ) {
    super(`Missing env var "${varName}" at ${configPath}`);
  }
}

function substituteString(
  value: string,
  env: NodeJS.ProcessEnv,
  configPath: string
): string {
  return value.replace(/\$\{([A-Z_][A-Z0-9_]*)\}/g, (match, varName) => {
    const envValue = env[varName];
    if (!envValue) {
      throw new MissingEnvVarError(varName, configPath);
    }
    return envValue;
  });
}

export function resolveConfigEnvVars(
  config: unknown,
  env: NodeJS.ProcessEnv
): unknown {
  return traverse(config, (value, path) => {
    if (typeof value === 'string') {
      return substituteString(value, env, path);
    }
    return value;
  });
}
```

#### 步骤 4: 实现配置包含(includes.ts)

**目标**: 解析 `$include` 指令,递归加载外部配置文件。

**关键点**:
- 检测循环引用,防止死循环
- 相对路径基于当前文件目录
- 合并策略:深度合并对象,数组替换

**伪代码**:
```typescript
export function resolveConfigIncludes(
  config: unknown,
  basePath: string,
  deps: { readFile: (path: string) => string; parseJson: (raw: string) => unknown }
): unknown {
  const visitedPaths = new Set<string>();

  function resolve(value: unknown, currentPath: string): unknown {
    if (!isPlainObject(value)) return value;

    if ('$include' in value) {
      const includePath = path.resolve(path.dirname(currentPath), value.$include);

      if (visitedPaths.has(includePath)) {
        throw new CircularIncludeError(includePath);
      }

      visitedPaths.add(includePath);
      const raw = deps.readFile(includePath);
      const parsed = deps.parseJson(raw);
      return resolve(parsed, includePath);
    }

    // 递归处理对象
    const result: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      result[key] = resolve(val, currentPath);
    }
    return result;
  }

  return resolve(config, basePath);
}
```

#### 步骤 5: 实现配置验证(validation.ts)

**目标**: 使用 Zod Schema 验证配置,收集错误和警告。

**关键点**:
- 返回详细的错误路径和信息
- 区分错误(errors)和警告(warnings)
- 支持插件扩展 Schema

**伪代码**:
```typescript
interface ValidationResult {
  ok: boolean;
  config: MoltbotConfig;
  issues: ConfigIssue[];
  warnings: ConfigIssue[];
}

export function validateConfigObjectWithPlugins(
  config: unknown
): ValidationResult {
  const result = MoltbotSchema.safeParse(config);

  if (!result.success) {
    return {
      ok: false,
      config: {},
      issues: result.error.issues.map(issue => ({
        path: issue.path.join('.'),
        message: issue.message
      })),
      warnings: []
    };
  }

  return {
    ok: true,
    config: result.data,
    issues: [],
    warnings: [] // 可以添加自定义警告逻辑
  };
}
```

#### 步骤 6: 实现默认值应用(defaults.ts)

**目标**: 为未配置的字段填充默认值。

**关键点**:
- 默认值应用遵循"最少惊讶"原则
- 对于复杂对象,使用深度合并
- 特殊字段(如 Agent 默认值)需要特殊处理

**伪代码**:
```typescript
export function applyModelDefaults(cfg: MoltbotConfig): MoltbotConfig {
  return {
    ...cfg,
    models: {
      default: cfg.models?.default ?? 'anthropic/claude-sonnet-4-5',
      providers: cfg.models?.providers ?? {},
      // ... 其他默认值
    }
  };
}

export function applyAgentDefaults(cfg: MoltbotConfig): MoltbotConfig {
  const agents = cfg.agents?.list ?? [];

  // 如果没有 Agent,创建一个默认 Agent
  if (agents.length === 0) {
    return {
      ...cfg,
      agents: {
        ...cfg.agents,
        list: [{
          id: 'main',
          name: 'Main Agent',
          default: true,
          provider: 'anthropic',
          model: 'sonnet'
        }]
      }
    };
  }

  return cfg;
}
```

#### 步骤 7: 实现配置 I/O(io.ts)

**目标**: 实现配置的加载、保存、快照读取功能。

**关键点**:
- 工厂模式创建 ConfigIO 对象
- 原子写入:先写临时文件,再原子重命名
- 自动备份:保留最近 5 个版本
- 缓存管理:加载后缓存,写入后清除

**伪代码**:
```typescript
export function createConfigIO(overrides: ConfigIoDeps = {}) {
  const deps = normalizeDeps(overrides);
  const configPath = resolveConfigPath(deps.env, deps.homedir);

  function loadConfig(): MoltbotConfig {
    try {
      if (!deps.fs.existsSync(configPath)) {
        return applyDefaults({});
      }

      const raw = deps.fs.readFileSync(configPath, 'utf-8');
      const parsed = deps.json5.parse(raw);
      const included = resolveConfigIncludes(parsed, configPath, deps);
      const substituted = resolveConfigEnvVars(included, deps.env);
      const validated = validateConfigObjectWithPlugins(substituted);

      if (!validated.ok) {
        deps.logger.error('Invalid config:', validated.issues);
        return applyDefaults({});
      }

      return applyDefaults(validated.config);
    } catch (err) {
      deps.logger.error('Failed to load config:', err);
      return applyDefaults({});
    }
  }

  async function writeConfigFile(cfg: MoltbotConfig) {
    const validated = validateConfigObjectWithPlugins(cfg);
    if (!validated.ok) {
      throw new Error('Config validation failed');
    }

    // 备份当前配置
    if (deps.fs.existsSync(configPath)) {
      await rotateConfigBackups(configPath, deps.fs.promises);
    }

    // 写入临时文件
    const tmpPath = `${configPath}.${process.pid}.tmp`;
    const json = JSON.stringify(cfg, null, 2);
    await deps.fs.promises.writeFile(tmpPath, json, { mode: 0o600 });

    // 原子重命名
    await deps.fs.promises.rename(tmpPath, configPath);

    // 清除缓存
    clearConfigCache();
  }

  return { configPath, loadConfig, writeConfigFile };
}

// 全局导出(带缓存)
export function loadConfig(): MoltbotConfig {
  const io = createConfigIO();
  // ... 缓存逻辑
  return io.loadConfig();
}
```

### 6.2 技术难点

#### 难点 1: 环境变量替换的边界情况

**问题**: 如何正确处理各种边界情况,如转义、嵌套、非法格式等?

**解决方案**:
- 使用状态机或字符遍历,而非简单的正则替换
- 明确定义规则:只匹配大写字母和下划线
- 提供转义语法:`$${VAR}` → `${VAR}`

**示例**:
```typescript
// 边界情况测试
const testCases = [
  { input: '${API_KEY}', env: { API_KEY: 'abc' }, expected: 'abc' },
  { input: '$${API_KEY}', env: {}, expected: '${API_KEY}' }, // 转义
  { input: '${api_key}', env: { api_key: 'abc' }, expected: '${api_key}' }, // 小写,不替换
  { input: '${MISSING}', env: {}, expected: Error }, // 缺失,抛错
];
```

#### 难点 2: 配置包含的循环检测

**问题**: 如何检测和防止配置包含的循环引用?

**解决方案**:
- 维护一个 `visitedPaths` Set,记录已访问的文件路径
- 在加载文件前检查是否已访问,如果是则抛出 `CircularIncludeError`

**伪代码**:
```typescript
function resolveIncludes(config: unknown, path: string, visited: Set<string>) {
  const absPath = path.resolve(path);

  if (visited.has(absPath)) {
    throw new CircularIncludeError(absPath);
  }

  visited.add(absPath);

  // ... 递归处理
}
```

#### 难点 3: 原子写入的跨平台实现

**问题**: Windows 不支持原子 rename(如果目标文件存在)。

**解决方案**:
- 先尝试 `fs.rename()` (原子操作)
- 如果失败(EPERM/EEXIST),回退到 `fs.copyFile()` + `fs.unlink()`
- 确保目标文件权限为 `0600`

**伪代码**:
```typescript
try {
  await fs.promises.rename(tmpPath, configPath); // 原子操作
} catch (err) {
  if (err.code === 'EPERM' || err.code === 'EEXIST') {
    // Windows 回退方案
    await fs.promises.copyFile(tmpPath, configPath);
    await fs.promises.chmod(configPath, 0o600);
    await fs.promises.unlink(tmpPath);
  } else {
    throw err;
  }
}
```

### 6.3 测试策略

#### 单元测试

**测试覆盖**:
- 环境变量替换(各种边界情况)
- 配置包含(循环检测、相对路径)
- Schema 验证(有效/无效配置)
- 默认值应用(空配置、部分配置)
- 配置 I/O(加载、保存、备份)

**测试工具**:
- **Vitest**: 单元测试框架
- **Mock fs**: 模拟文件系统
- **Mock env**: 模拟环境变量

**示例测试**:
```typescript
import { describe, it, expect, vi } from 'vitest';
import { createConfigIO } from './io.js';

describe('createConfigIO', () => {
  it('should load config from file', () => {
    const mockFs = {
      existsSync: vi.fn(() => true),
      readFileSync: vi.fn(() => '{ "logging": { "level": "info" } }')
    };

    const io = createConfigIO({ fs: mockFs });
    const config = io.loadConfig();

    expect(config.logging?.level).toBe('info');
  });

  it('should handle missing env vars', () => {
    const mockFs = {
      existsSync: vi.fn(() => true),
      readFileSync: vi.fn(() => '{ "models": { "apiKey": "${MISSING_KEY}" } }')
    };

    const io = createConfigIO({ fs: mockFs, env: {} });

    expect(() => io.loadConfig()).toThrow(MissingEnvVarError);
  });
});
```

#### 集成测试

**测试场景**:
- 完整的配置加载流程(文件 → 解析 → 验证 → 应用)
- 配置保存和重新加载(确保幂等性)
- 配置备份和恢复

### 6.4 参考代码位置

| 功能 | Moltbot 代码位置 |
|------|-----------------|
| 配置 I/O | `src/config/io.ts:187-527` |
| 类型定义 | `src/config/types.ts`, `src/config/types.*.ts` |
| Zod Schema | `src/config/zod-schema.ts:30-554` |
| 环境变量替换 | `src/config/env-substitution.ts:46-100` |
| 配置包含 | `src/config/includes.ts` |
| 配置验证 | `src/config/validation.ts` |
| 默认值应用 | `src/config/defaults.ts:95-106` |
| 路径规范化 | `src/config/normalize-paths.ts` |
| 迁移检测 | `src/config/legacy.ts` |

---

## 7. 验收标准

### 7.1 功能验收

#### 验收项 1: 配置加载

**测试步骤**:
1. 创建配置文件 `~/.clawdbot/config.json5`
2. 写入有效的配置
3. 调用 `loadConfig()`
4. 验证返回的配置对象与文件内容一致

**通过标准**:
- 配置成功加载
- 所有字段正确解析
- 类型与 TypeScript 定义一致

#### 验收项 2: 环境变量替换

**测试步骤**:
1. 设置环境变量 `ANTHROPIC_API_KEY=test-key`
2. 配置文件使用 `${ANTHROPIC_API_KEY}`
3. 加载配置
4. 验证替换后的值

**通过标准**:
- 环境变量正确替换
- 缺失环境变量时抛出 `MissingEnvVarError`

#### 验收项 3: Schema 验证

**测试步骤**:
1. 创建无效配置(如端口号为负数)
2. 调用 `loadConfig()`
3. 验证错误信息

**通过标准**:
- 验证失败,返回空配置
- 输出详细的错误路径和信息

#### 验收项 4: 配置保存

**测试步骤**:
1. 构建配置对象
2. 调用 `writeConfigFile(cfg)`
3. 验证文件已创建
4. 重新加载配置,验证一致性

**通过标准**:
- 配置文件成功写入
- 文件权限为 `0600`
- 备份文件已创建

### 7.2 性能验收

| 指标 | 测量结果 | 是否通过 |
|------|---------|---------|
| 配置加载时间 | < 100ms | ✓ |
| 配置验证时间 | < 50ms | ✓ |
| 配置写入时间 | < 200ms | ✓ |

**测量方法**:
```typescript
const start = Date.now();
const config = loadConfig();
const elapsed = Date.now() - start;
console.log(`Load time: ${elapsed}ms`);
```

### 7.3 测试覆盖

**要求**: 测试覆盖率 ≥ 70%

**检查命令**:
```bash
pnpm test:coverage
```

**覆盖范围**:
- 所有核心函数(loadConfig, writeConfigFile, validateSchema 等)
- 边界情况(空配置、无效配置、循环引用等)
- 错误处理(MissingEnvVarError, CircularIncludeError 等)

---

## 8. 附录

### 8.1 配置文件完整示例

```json5
// ~/.clawdbot/config.json5
{
  // 元数据(自动生成)
  meta: {
    lastTouchedVersion: "2025.1.29",
    lastTouchedAt: "2026-01-29T10:30:00Z"
  },

  // 环境变量配置
  env: {
    shellEnv: {
      enabled: true,
      timeoutMs: 5000
    },
    vars: {
      MY_VAR: "custom-value"
    }
  },

  // 日志配置
  logging: {
    level: "info",
    file: "~/.clawdbot/logs/moltbot.log",
    consoleLevel: "warn",
    consoleStyle: "pretty"
  },

  // 模型配置
  models: {
    default: "anthropic/claude-sonnet-4-5",
    providers: {
      anthropic: {
        apiKey: "${ANTHROPIC_API_KEY}"
      },
      openai: {
        apiKey: "${OPENAI_API_KEY}"
      }
    }
  },

  // Agent 配置
  agents: {
    list: [
      {
        id: "main",
        name: "主助手",
        default: true,
        provider: "anthropic",
        model: "sonnet",
        dir: "~/.clawdbot/agents/main"
      },
      {
        id: "research",
        name: "研究助手",
        provider: "anthropic",
        model: "opus",
        dir: "~/.clawdbot/agents/research"
      }
    ]
  },

  // 渠道配置
  channels: {
    whatsapp: {
      enabled: true,
      accountId: "default"
    },
    telegram: {
      enabled: true,
      accounts: [
        {
          id: "default",
          token: "${TELEGRAM_BOT_TOKEN}"
        }
      ]
    }
  },

  // Gateway 配置
  gateway: {
    mode: "local",
    port: 18789,
    bind: "loopback",
    auth: {
      mode: "token",
      token: "${CLAWDBOT_GATEWAY_TOKEN}"
    },
    reload: {
      mode: "hybrid",
      debounceMs: 1000
    }
  },

  // 会话配置
  session: {
    scope: "per-sender",
    dmScope: "main",
    typingMode: "thinking",
    reset: {
      mode: "daily",
      atHour: 4
    }
  }
}
```

### 8.2 环境变量清单

| 环境变量 | 说明 | 必需 |
|---------|------|------|
| `ANTHROPIC_API_KEY` | Anthropic API 密钥 | 使用 Anthropic 时必需 |
| `OPENAI_API_KEY` | OpenAI API 密钥 | 使用 OpenAI 时必需 |
| `TELEGRAM_BOT_TOKEN` | Telegram Bot Token | 使用 Telegram 时必需 |
| `CLAWDBOT_CONFIG_PATH` | 配置文件路径 | 否(默认 `~/.clawdbot/config.json5`) |
| `CLAWDBOT_STATE_DIR` | 状态目录 | 否(默认 `~/.clawdbot`) |
| `CLAWDBOT_CONFIG_CACHE_MS` | 配置缓存时间(ms) | 否(默认 200) |
| `CLAWDBOT_DISABLE_CONFIG_CACHE` | 禁用配置缓存 | 否 |

### 8.3 错误代码和处理

| 错误代码 | 错误名称 | 说明 | 处理方式 |
|---------|---------|------|---------|
| `INVALID_CONFIG` | 配置验证失败 | 配置不符合 Schema | 输出错误,使用默认配置 |
| `MISSING_ENV_VAR` | 缺失环境变量 | 配置引用的环境变量未定义 | 抛出 `MissingEnvVarError` |
| `CIRCULAR_INCLUDE` | 循环包含 | 配置包含检测到循环引用 | 抛出 `CircularIncludeError` |
| `PARSE_ERROR` | JSON5 解析失败 | 配置文件格式错误 | 输出错误,使用默认配置 |

---

**文档完成** ✅

下一步: 实现配置系统代码,并编写单元测试。
