# 27 - 音视频处理需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 25-媒体类型检测需求
> **后续文档**: 28-PDF处理需求

---

## 1. 需求概述

### 1.1 目标描述

实现**音频和视频的格式转换、元数据提取、转码**等功能。

**核心目标:**
- **音频转换**: OGG → MP3, WebM → MP3
- **视频转码**: WebM → MP4
- **元数据提取**: 时长、编码格式、比特率
- **音频标签**: 提取 ID3 标签

---

## 2. 音频处理

### 2.1 格式转换

**使用 FFmpeg**:

```typescript
import ffmpeg from 'fluent-ffmpeg';

export async function convertAudio(params: {
  inputPath: string;
  outputPath: string;
  format: 'mp3' | 'wav' | 'ogg';
  bitrate?: string;
}): Promise<void> {
  return new Promise((resolve, reject) => {
    ffmpeg(params.inputPath)
      .toFormat(params.format)
      .audioBitrate(params.bitrate ?? '128k')
      .on('end', () => resolve())
      .on('error', (err) => reject(err))
      .save(params.outputPath);
  });
}
```

### 2.2 元数据提取

```typescript
export async function getAudioMetadata(filePath: string): Promise<{
  duration: number;
  codec: string;
  bitrate: number;
  sampleRate: number;
}> {
  return new Promise((resolve, reject) => {
    ffmpeg.ffprobe(filePath, (err, metadata) => {
      if (err) return reject(err);

      const audio = metadata.streams.find(s => s.codec_type === 'audio');
      if (!audio) return reject(new Error('No audio stream'));

      resolve({
        duration: metadata.format.duration ?? 0,
        codec: audio.codec_name ?? 'unknown',
        bitrate: audio.bit_rate ?? 0,
        sampleRate: audio.sample_rate ?? 0
      });
    });
  });
}
```

---

## 3. 视频处理

### 3.1 视频转码

```typescript
export async function convertVideo(params: {
  inputPath: string;
  outputPath: string;
  format: 'mp4' | 'webm';
  codec?: string;
}): Promise<void> {
  return new Promise((resolve, reject) => {
    ffmpeg(params.inputPath)
      .toFormat(params.format)
      .videoCodec(params.codec ?? 'libx264')
      .audioCodec('aac')
      .on('end', () => resolve())
      .on('error', (err) => reject(err))
      .save(params.outputPath);
  });
}
```

### 3.2 视频元数据

```typescript
export async function getVideoMetadata(filePath: string): Promise<{
  duration: number;
  width: number;
  height: number;
  fps: number;
  codec: string;
}> {
  return new Promise((resolve, reject) => {
    ffmpeg.ffprobe(filePath, (err, metadata) => {
      if (err) return reject(err);

      const video = metadata.streams.find(s => s.codec_type === 'video');
      if (!video) return reject(new Error('No video stream'));

      resolve({
        duration: metadata.format.duration ?? 0,
        width: video.width ?? 0,
        height: video.height ?? 0,
        fps: eval(video.r_frame_rate ?? '0') || 0,
        codec: video.codec_name ?? 'unknown'
      });
    });
  });
}
```

---

**文档完成** ✅
