# 24 - 媒体管道基础需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 07-渠道抽象层需求
> **后续文档**: 25-媒体类型检测需求

---

## 1. 需求概述

### 1.1 目标描述

实现**统一的媒体处理管道**,处理图片、音频、视频、PDF 等多种媒体类型的接收、存储、转换和分发。

**核心目标:**
- **媒体接收**: 从消息渠道接收各类媒体文件
- **存储管理**: 统一的媒体存储和检索
- **格式转换**: 自动转换为目标渠道支持的格式
- **内容服务**: 通过 HTTP 服务访问媒体文件

---

## 2. 核心概念

### 2.1 媒体类型

| 类型 | MIME 类型 | 扩展名 |
|------|-----------|--------|
| **图片** | `image/jpeg`, `image/png`, `image/webp` | `.jpg`, `.png`, `.webp` |
| **音频** | `audio/mpeg`, `audio/ogg`, `audio/wav` | `.mp3`, `.ogg`, `.wav` |
| **视频** | `video/mp4`, `video/webm` | `.mp4`, `.webm` |
| **文档** | `application/pdf` | `.pdf` |
| **压缩包** | `application/zip`, `application/gzip` | `.zip`, `.gz` |

### 2.2 媒体管道流程

```
接收媒体
  ↓
检测 MIME 类型
  ↓
存储到本地
  ├─ 生成唯一 ID
  ├─ 保存文件
  └─ 记录元数据
  ↓
(可选)格式转换
  ├─ 图片转换(HEIC → JPEG)
  ├─ 音频转换(OGG → MP3)
  └─ 视频转换(WEBM → MP4)
  ↓
生成访问 URL
  ↓
提供给 Agent / 发送到渠道
```

### 2.3 媒体存储结构

**位置**: `~/.clawdbot/media/`

**目录结构**:
```
~/.clawdbot/media/
├── images/
│   ├── abc123.jpg
│   ├── def456.png
│   └── ...
├── audio/
│   ├── voice001.mp3
│   └── ...
├── video/
│   └── ...
├── documents/
│   └── ...
└── metadata.json
```

---

## 3. 关键实现

### 3.1 媒体接收

#### 从消息接收

```typescript
export async function handleIncomingMessage(msg: IncomingMessage) {
  // 检查是否包含媒体
  if (!msg.media) return;

  // 下载媒体
  const buffer = await downloadMedia(msg.media);

  // 存储媒体
  const mediaId = await storeMedia({
    buffer,
    mimeType: msg.media.mimeType,
    filename: msg.media.filename
  });

  // 生成访问 URL
  const url = generateMediaUrl(mediaId);

  // 传递给 Agent
  return {
    text: msg.text,
    mediaUrl: url,
    mediaType: msg.media.type
  };
}
```

### 3.2 媒体存储

```typescript
export async function storeMedia(params: {
  buffer: Buffer;
  mimeType?: string;
  filename?: string;
}): Promise<string> {
  // 1. 检测 MIME 类型
  const mime = await detectMime({
    buffer: params.buffer,
    headerMime: params.mimeType,
    filePath: params.filename
  });

  // 2. 确定文件扩展名
  const ext = getExtensionByMime(mime) || '.bin';

  // 3. 生成唯一 ID
  const mediaId = generateMediaId();

  // 4. 确定存储路径
  const mediaKind = mediaKindFromMime(mime);
  const dir = path.join(MEDIA_DIR, mediaKind);
  fs.mkdirSync(dir, { recursive: true });

  const filePath = path.join(dir, `${mediaId}${ext}`);

  // 5. 写入文件
  await fs.writeFile(filePath, params.buffer);

  // 6. 记录元数据
  await saveMetadata({
    id: mediaId,
    mimeType: mime,
    size: params.buffer.length,
    path: filePath,
    createdAt: new Date().toISOString()
  });

  return mediaId;
}
```

### 3.3 媒体服务

#### HTTP 服务器

```typescript
export function createMediaServer(port: number) {
  const server = http.createServer(async (req, res) => {
    // 解析 URL: /media/:mediaId
    const match = req.url?.match(/^\/media\/([a-zA-Z0-9_-]+)/);
    if (!match) {
      res.writeHead(404);
      res.end('Not Found');
      return;
    }

    const mediaId = match[1];

    // 查找媒体文件
    const metadata = await getMetadata(mediaId);
    if (!metadata) {
      res.writeHead(404);
      res.end('Media not found');
      return;
    }

    // 读取文件
    const buffer = await fs.readFile(metadata.path);

    // 设置响应头
    res.writeHead(200, {
      'Content-Type': metadata.mimeType,
      'Content-Length': buffer.length,
      'Cache-Control': 'public, max-age=31536000'
    });

    res.end(buffer);
  });

  server.listen(port);
  return server;
}
```

---

## 4. MIME 类型检测

### 4.1 检测策略

**优先级**:
1. 魔数检测(Buffer 前 256 字节)
2. HTTP Header `Content-Type`
3. 文件扩展名

### 4.2 实现

```typescript
export async function detectMime(opts: {
  buffer?: Buffer;
  headerMime?: string | null;
  filePath?: string;
}): Promise<string | undefined> {
  // 1. 尝试魔数检测
  if (opts.buffer) {
    const sniffed = await sniffMime(opts.buffer);
    if (sniffed && !isGenericMime(sniffed)) {
      return sniffed;
    }
  }

  // 2. 使用 HTTP Header
  const headerMime = normalizeHeaderMime(opts.headerMime);
  if (headerMime && !isGenericMime(headerMime)) {
    return headerMime;
  }

  // 3. 根据文件扩展名
  if (opts.filePath) {
    const ext = getFileExtension(opts.filePath);
    if (ext) {
      const mime = MIME_BY_EXT[ext];
      if (mime) return mime;
    }
  }

  // 4. 回退到魔数检测(即使是通用 MIME)
  if (opts.buffer) {
    const sniffed = await sniffMime(opts.buffer);
    if (sniffed) return sniffed;
  }

  // 5. 回退到 Header(即使是通用 MIME)
  if (headerMime) return headerMime;

  return undefined;
}
```

---

## 5. 媒体元数据

### 5.1 元数据结构

```typescript
type MediaMetadata = {
  id: string;
  mimeType: string;
  size: number;           // 字节大小
  path: string;           // 文件路径
  filename?: string;      // 原始文件名
  width?: number;         // 图片宽度
  height?: number;        // 图片高度
  duration?: number;      // 音视频时长(秒)
  createdAt: string;      // 创建时间
};
```

### 5.2 元数据存储

**方式 1: JSON 文件**

```json
{
  "abc123": {
    "id": "abc123",
    "mimeType": "image/jpeg",
    "size": 102400,
    "path": "/path/to/images/abc123.jpg",
    "width": 1920,
    "height": 1080,
    "createdAt": "2026-01-29T10:00:00Z"
  }
}
```

**方式 2: 数据库(可选)**

```sql
CREATE TABLE media (
  id TEXT PRIMARY KEY,
  mime_type TEXT NOT NULL,
  size INTEGER NOT NULL,
  path TEXT NOT NULL,
  width INTEGER,
  height INTEGER,
  duration REAL,
  created_at TEXT NOT NULL
);
```

---

## 6. 媒体 URL 生成

### 6.1 本地 URL

```typescript
export function generateMediaUrl(mediaId: string): string {
  return `http://localhost:${MEDIA_SERVER_PORT}/media/${mediaId}`;
}
```

### 6.2 外部访问 URL

**场景**: 需要从外网访问(如移动客户端)。

```typescript
export function generatePublicUrl(mediaId: string): string {
  const baseUrl = process.env.PUBLIC_MEDIA_URL || 'http://localhost:3000';
  return `${baseUrl}/media/${mediaId}`;
}
```

---

## 7. 媒体下载

### 7.1 从 URL 下载

```typescript
export async function fetchMedia(url: string): Promise<Buffer> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch media: ${response.statusText}`);
  }

  const buffer = Buffer.from(await response.arrayBuffer());
  return buffer;
}
```

### 7.2 从渠道下载

```typescript
// Telegram
export async function downloadTelegramMedia(
  fileId: string,
  token: string
): Promise<Buffer> {
  // 1. 获取文件路径
  const fileInfo = await telegramApi.getFile(fileId, token);

  // 2. 下载文件
  const url = `https://api.telegram.org/file/bot${token}/${fileInfo.file_path}`;
  return await fetchMedia(url);
}

// WhatsApp
export async function downloadWhatsAppMedia(
  messageKey: proto.IMessageKey,
  message: proto.IMessage
): Promise<Buffer> {
  return await whatsappSock.downloadMediaMessage(message);
}
```

---

## 8. 清理策略

### 8.1 自动清理

**策略**: 定期清理超过一定时间的媒体文件。

```typescript
export async function cleanupOldMedia(maxAgeDays: number) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);

  const metadata = await loadAllMetadata();

  for (const [id, meta] of Object.entries(metadata)) {
    const createdAt = new Date(meta.createdAt);
    if (createdAt < cutoffDate) {
      // 删除文件
      await fs.unlink(meta.path);

      // 删除元数据
      delete metadata[id];
    }
  }

  await saveAllMetadata(metadata);
}
```

### 8.2 手动清理

```bash
# CLI 命令
moltbot media clean --older-than 30d
```

---

## 9. 配置

### 9.1 媒体配置

```json5
{
  media: {
    dir: "~/.clawdbot/media",
    server: {
      enabled: true,
      port: 3030,
      host: "0.0.0.0"
    },
    cleanup: {
      enabled: true,
      maxAgeDays: 30
    }
  }
}
```

---

**文档完成** ✅
