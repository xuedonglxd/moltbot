# 19 - 工具注册与发现需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 18-工具抽象层需求, 06-插件系统需求
> **后续文档**: 20-内置工具集需求

---

## 1. 需求概述

### 1.1 目标描述

实现**工具注册与发现机制**,支持核心工具、插件工具的动态注册和加载,并处理工具名称冲突、权限过滤等问题。

**核心目标:**
- **工具发现**: 从核心系统和插件中发现可用工具
- **动态注册**: 支持运行时注册新工具
- **冲突解决**: 处理工具名称冲突
- **权限过滤**: 根据配置过滤可用工具

---

## 2. 核心概念

### 2.1 工具来源

| 来源 | 说明 | 示例 |
|------|------|------|
| **核心工具** | 内置工具,始终可用 | `read`, `write`, `exec` |
| **编码工具** | pi-coding-agent 提供 | `edit`, `apply_patch` |
| **Moltbot 工具** | 特有工具 | `message`, `sessions_send`, `web_search` |
| **插件工具** | 插件注册的工具 | `memory_search`, `llm_task` |
| **渠道工具** | 特定渠道的工具 | `telegram_send_poll`, `whatsapp_send_contact` |

### 2.2 工具注册流程

```
插件加载
  ↓
调用 api.registerTool()
  ↓
存储到 PluginRegistry
  ↓
resolvePluginTools() 发现
  ↓
合并到工具列表
  ↓
过滤与权限检查
  ↓
返回最终工具列表
```

### 2.3 工具元数据

```typescript
type PluginToolMeta = {
  pluginId: string;    // 来源插件 ID
  optional: boolean;   // 是否可选(需显式启用)
};

// 存储工具元数据
const pluginToolMeta = new WeakMap<AnyAgentTool, PluginToolMeta>();
```

---

## 3. 关键实现

### 3.1 实现步骤

#### 步骤 1: 插件注册工具

```typescript
// 插件中注册工具
export default function myPlugin(api: MoltbotPluginApi) {
  api.registerTool(
    {
      name: 'my_custom_tool',
      description: 'My custom tool',
      parameters: Type.Object({
        input: Type.String()
      }),
      async execute(toolCallId, params) {
        // 工具逻辑
        return jsonResult({ result: 'ok' });
      }
    },
    {
      optional: false  // 是否可选
    }
  );
}
```

#### 步骤 2: 工具发现

```typescript
export function resolvePluginTools(params: {
  context: MoltbotPluginToolContext;
  existingToolNames?: Set<string>;
  toolAllowlist?: string[];
}): AnyAgentTool[] {
  // 1. 加载插件
  const registry = loadMoltbotPlugins({
    config: params.context.config,
    workspaceDir: params.context.workspaceDir
  });

  const tools: AnyAgentTool[] = [];
  const existing = params.existingToolNames ?? new Set<string>();
  const allowlist = normalizeAllowlist(params.toolAllowlist);

  // 2. 遍历注册的工具
  for (const entry of registry.tools) {
    // 3. 调用工具工厂
    const resolved = entry.factory(params.context);
    if (!resolved) continue;

    const list = Array.isArray(resolved) ? resolved : [resolved];

    // 4. 可选工具过滤
    const filtered = entry.optional
      ? list.filter(tool => isOptionalToolAllowed({
          toolName: tool.name,
          pluginId: entry.pluginId,
          allowlist
        }))
      : list;

    // 5. 冲突检测
    for (const tool of filtered) {
      if (existing.has(tool.name)) {
        log.error(`Tool name conflict: ${tool.name}`);
        continue;
      }

      existing.add(tool.name);
      pluginToolMeta.set(tool, {
        pluginId: entry.pluginId,
        optional: entry.optional
      });
      tools.push(tool);
    }
  }

  return tools;
}
```

#### 步骤 3: 核心工具 + 插件工具合并

```typescript
export function createMoltbotCodingTools(options?: {
  config?: MoltbotConfig;
  workspaceDir?: string;
  // ...
}) {
  // 1. 加载核心工具
  const coreTools = [
    ...codingTools(),           // read, write, edit
    createExecTool(),           // exec
    createProcessTool(),        // process
    // ...
  ];

  const toolNames = new Set(coreTools.map(t => t.name));

  // 2. 加载 Moltbot 特有工具
  const moltbotTools = createMoltbotTools({
    messageProvider: options?.messageProvider,
    config: options?.config,
    // ...
  });

  moltbotTools.forEach(t => toolNames.add(t.name));

  // 3. 加载插件工具
  const pluginTools = resolvePluginTools({
    context: {
      config: options?.config,
      workspaceDir: options?.workspaceDir,
      agentDir: options?.agentDir,
      sessionKey: options?.sessionKey,
      messageChannel: options?.messageProvider,
      sandboxed: !!options?.sandbox
    },
    existingToolNames: toolNames,
    toolAllowlist: options?.config?.tools?.allow
  });

  // 4. 合并所有工具
  const allTools = [...coreTools, ...moltbotTools, ...pluginTools];

  // 5. 应用权限策略
  return filterToolsByPolicy(allTools, toolPolicy);
}
```

---

## 4. 工具冲突解决

### 4.1 冲突检测

**规则**:
1. **核心工具优先**: 插件工具不能覆盖核心工具
2. **插件 ID 冲突**: 插件 ID 不能与核心工具名称冲突
3. **同名工具**: 后加载的工具会被忽略

**示例**:

```typescript
// 核心工具
const coreTools = ['read', 'write', 'exec'];

// 插件注册 'read' 工具 → 被拒绝
api.registerTool({ name: 'read', ... }); // ❌ 冲突

// 插件 ID 为 'exec' → 整个插件被阻止
const pluginId = 'exec'; // ❌ 与核心工具名冲突
```

### 4.2 冲突日志

```typescript
if (existing.has(tool.name)) {
  const message = `plugin tool name conflict (${entry.pluginId}): ${tool.name}`;
  log.error(message);
  registry.diagnostics.push({
    level: 'error',
    pluginId: entry.pluginId,
    source: entry.source,
    message
  });
  continue;
}
```

---

## 5. 可选工具

### 5.1 可选工具定义

**定义**:
- 插件工具默认不启用
- 需要在配置中显式启用

**注册方式**:

```typescript
api.registerTool(
  myTool,
  { optional: true }  // 标记为可选
);
```

### 5.2 启用可选工具

**配置方式**:

```json5
{
  tools: {
    allow: [
      "memory_search",        // 显式启用单个工具
      "my-plugin",            // 启用插件所有工具
      "group:plugins"         // 启用所有插件工具
    ]
  }
}
```

### 5.3 可选工具过滤

```typescript
function isOptionalToolAllowed(params: {
  toolName: string;
  pluginId: string;
  allowlist: Set<string>;
}): boolean {
  if (params.allowlist.size === 0) return false;

  const toolName = normalizeToolName(params.toolName);

  // 1. 检查工具名
  if (params.allowlist.has(toolName)) return true;

  // 2. 检查插件 ID
  const pluginKey = normalizeToolName(params.pluginId);
  if (params.allowlist.has(pluginKey)) return true;

  // 3. 检查 group:plugins
  return params.allowlist.has('group:plugins');
}
```

---

## 6. 工具工厂

### 6.1 工具工厂接口

```typescript
type MoltbotPluginToolFactory = (
  ctx: MoltbotPluginToolContext
) => AnyAgentTool | AnyAgentTool[] | null | undefined;
```

**上下文**:

```typescript
type MoltbotPluginToolContext = {
  config?: MoltbotConfig;
  workspaceDir?: string;
  agentDir?: string;
  agentId?: string;
  sessionKey?: string;
  messageChannel?: string;
  agentAccountId?: string;
  sandboxed?: boolean;
};
```

### 6.2 动态工具生成

**场景**: 根据上下文动态决定提供哪些工具。

**示例**:

```typescript
api.registerTool((ctx) => {
  // 仅在非沙箱环境提供
  if (ctx.sandboxed) return null;

  // 根据渠道提供不同工具
  if (ctx.messageChannel === 'telegram') {
    return [telegramSendPoll, telegramPinMessage];
  }

  if (ctx.messageChannel === 'whatsapp') {
    return [whatsappSendContact, whatsappSendLocation];
  }

  return null;
});
```

---

## 7. 渠道工具

### 7.1 渠道特定工具

**定义**:
- 仅在特定渠道会话中可用
- 通过 `listChannelAgentTools()` 加载

**示例**:

```typescript
// 获取渠道工具
const channelTools = listChannelAgentTools({
  provider: 'telegram',
  accountId: '123456',
  conversationId: '789',
  config: cfg
});

// 渠道工具: telegram_send_poll, telegram_pin_message, ...
```

### 7.2 渠道工具集成

```typescript
export function createMoltbotCodingTools(options) {
  // ...

  // 加载渠道工具
  const channelTools = options?.messageProvider
    ? listChannelAgentTools({
        provider: options.messageProvider,
        accountId: options.agentAccountId,
        conversationId: options.currentChannelId,
        config: options.config
      })
    : [];

  return [...coreTools, ...moltbotTools, ...pluginTools, ...channelTools];
}
```

---

## 8. 工具元数据查询

### 8.1 查询工具来源

```typescript
export function getPluginToolMeta(tool: AnyAgentTool): PluginToolMeta | undefined {
  return pluginToolMeta.get(tool);
}
```

**用途**:
- 判断工具是否来自插件
- 获取插件 ID
- 权限策略应用

### 8.2 使用示例

```typescript
const meta = getPluginToolMeta(tool);

if (meta) {
  console.log(`Tool ${tool.name} from plugin: ${meta.pluginId}`);
  console.log(`Is optional: ${meta.optional}`);
}
```

---

**文档完成** ✅
