# 07 - 渠道抽象层需求

> **版本**: v1.0
> **最后更新**: 2026-01-29
> **依赖文档**: 01-配置系统需求, 04-Gateway基础架构需求, 06-插件系统需求
> **后续文档**: 08-WhatsApp渠道需求, 09-Telegram渠道需求, 11-消息路由系统需求

---

## 1. 需求概述

### 1.1 目标描述

定义**统一的渠道接口**和**完整的消息处理管道**，作为所有消息渠道的抽象层。该层定义了渠道的生命周期、消息接收/发送的标准流程、消息去重机制和上下文构建逻辑。

**核心目标:**
- **统一接口**: 所有渠道实现相同的接口，互相可替换
- **消息处理管道**: 接收→解析→去重→上下文构建→分发的完整流程
- **生命周期管理**: 标准化的启动/停止/错误恢复流程
- **去重机制**: 防止消息重复处理

### 1.2 业务场景

#### 场景 1: 接收用户消息
**用户操作**: 用户在 WhatsApp 发送消息 "Hello"。

**完整处理流程**:
```
1. 消息接收 (Monitor)
   - WhatsApp SDK 接收到消息
   - 提取原始消息数据

2. 消息解析 (Parse)
   - 解析发送者信息
   - 解析聊天类型（DM/Group）
   - 解析消息内容和媒体

3. 消息去重 (Dedupe)
   - 计算去重键: channel + accountId + peer + messageId
   - 检查短期缓存
   - 如果重复，跳过处理

4. 上下文构建 (Context)
   - 构建 MsgContext 对象
   - 添加信封格式: "[WhatsApp] Alice: Hello"
   - 加载群组历史（如果是群组）

5. 路由解析 (Route)
   - resolveAgentRoute() 确定目标 Agent
   - 生成 Session Key

6. 分发处理 (Dispatch)
   - dispatchReplyFromConfig()
   - getReplyFromConfig()
   - 运行 Agent

7. 回复发送 (Reply)
   - 构建回复载荷
   - routeReply() 路由回复
   - deliverOutboundPayloads() 发送消息
```

#### 场景 2: 渠道启动
**系统操作**: Gateway 启动时启动所有渠道。

**启动流程**:
```
1. 加载渠道配置
2. 验证必需参数（Token、API Key 等）
3. 调用 startChannel()
4. 建立连接（WebSocket、长轮询等）
5. 注册消息监听器
6. 标记渠道为"运行中"
```

#### 场景 3: 渠道断线恢复
**系统操作**: WhatsApp 连接断开。

**恢复流程**:
```
1. 检测连接断开事件
2. 等待重连延迟（指数退避）
3. 尝试重新连接
4. 如果失败，继续退避重试
5. 如果成功，恢复消息监听
6. 检查是否有遗漏的消息
```

### 1.3 用户价值

- **一致性**: 所有渠道的行为一致，用户体验统一
- **可靠性**: 消息去重和错误恢复，不丢消息
- **可扩展性**: 新渠道只需实现标准接口

---

## 2. 核心概念

### 2.1 渠道接口(Channel Interface)

**定义**: 所有渠道必须实现的标准接口。

```typescript
interface Channel {
  /** 渠道 ID（如 "whatsapp", "telegram"） */
  id: string;

  /** 渠道名称（显示名） */
  name: string;

  /** 启动渠道 */
  start(config: ChannelConfig): Promise<void>;

  /** 停止渠道 */
  stop(): Promise<void>;

  /** 发送消息 */
  sendMessage(params: SendMessageParams): Promise<void>;

  /** 获取状态 */
  getStatus(): ChannelStatus;

  /** 探测连接状态（深度检查） */
  probe?(): Promise<ProbeResult>;
}
```

### 2.2 消息上下文(MsgContext)

**定义**: 消息处理过程中构建的完整上下文对象。

**关键字段**:
```typescript
interface MsgContext {
  // 消息内容
  Body: string;                    // 完整消息体（带信封）
  BodyForAgent: string;            // 给 Agent 的消息体
  RawBody: string;                 // 原始消息

  // 路由信息
  SessionKey: string;              // 会话键
  AgentId: string;                 // 目标 Agent ID
  Provider: string;                // 渠道（whatsapp/telegram）
  Surface: string;                 // 表面（通常同 Provider）

  // 发送者信息
  From: string;                    // 发送者 ID
  SenderName: string;              // 发送者名称
  To: string;                      // 接收者 ID

  // 聊天信息
  ChatType: "direct" | "group";    // 聊天类型
  GroupId?: string;                // 群组 ID（如果是群组）

  // 消息元数据
  MessageSid: string;              // 消息 ID
  Timestamp: number;               // 时间戳

  // 媒体附件
  MediaUrls?: string[];            // 媒体 URL 列表
  MediaTypes?: string[];           // 媒体类型
}
```

### 2.3 消息去重

**去重键计算**:
```typescript
function computeDedupeKey(msg: InboundMessage): string {
  return `${msg.channel}:${msg.accountId}:${msg.peer.kind}:${msg.peer.id}:${msg.messageId}`;
}
```

**去重缓存**:
- 使用 LRU 缓存，保留最近 1000 条消息
- TTL: 5 分钟
- 目的: 防止渠道重连后重复投递消息

### 2.4 信封格式(Envelope)

**定义**: 在消息前添加元数据前缀，帮助 Agent 理解消息来源。

**格式**:
```
[渠道名] 发送者: 消息内容
```

**示例**:
```
[WhatsApp] Alice: Hello, can you help me?
[Telegram] @bob: What's the weather today?
[Discord] Charlie (in #general): Anyone online?
```

**用途**:
- Agent 可以识别消息来源
- 群组消息中区分发送者
- 支持多渠道路由

### 2.5 渠道生命周期

**状态机**:
```
[Stopped] ──start()──> [Starting] ──success──> [Running]
                             │                     │
                             └──fail──> [Error]   │
                                            │      │
                                            │      │
[Stopped] <──stop()─────────────────────────┴─────┘
```

**生命周期钩子**:
- `onStart()` - 启动前
- `onStarted()` - 启动后
- `onStop()` - 停止前
- `onStopped()` - 停止后
- `onError()` - 错误发生
- `onMessage()` - 消息接收

---

## 3. 功能需求

### 3.1 核心功能列表

#### P0 功能

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F01** | 渠道接口定义 | 定义 Channel 接口 |
| **F02** | 消息接收流程 | processMessage() 完整流程 |
| **F03** | 消息去重 | shouldSkipDuplicateInbound() |
| **F04** | 上下文构建 | finalizeInboundContext() |
| **F05** | 信封格式化 | formatAgentEnvelope() |
| **F06** | 渠道启动/停止 | start()/stop() |

#### P1 功能

| 功能 ID | 功能名称 | 说明 |
|---------|---------|------|
| **F07** | 错误恢复 | 自动重连机制 |
| **F08** | 状态查询 | getStatus()/probe() |
| **F09** | 群组历史 | 加载群组消息历史 |

---

## 4. 架构设计

### 4.1 消息处理管道

```
接收消息
  ↓
processMessage()
  ↓
解析消息 (parse)
  ↓
路由 (resolveAgentRoute)
  ↓
去重检查 (shouldSkipDuplicate)
  ├─ 重复 → 跳过
  └─ 新消息 → 继续
  ↓
构建上下文 (finalizeInboundContext)
  ↓
快速中止检查 (tryFastAbort)
  ↓
分发处理 (dispatchReplyFromConfig)
  ↓
获取回复 (getReplyFromConfig)
  ↓
路由回复 (routeReply)
  ↓
发送消息 (deliverOutboundPayloads)
```

### 4.2 接口定义

```typescript
// 渠道接口
export interface Channel {
  id: string;
  name: string;
  start(config: ChannelConfig): Promise<void>;
  stop(): Promise<void>;
  sendMessage(params: SendMessageParams): Promise<void>;
  getStatus(): ChannelStatus;
  probe?(): Promise<ProbeResult>;
}

// 消息上下文
export interface MsgContext {
  Body: string;
  BodyForAgent: string;
  RawBody: string;
  SessionKey: string;
  AgentId: string;
  Provider: string;
  From: string;
  To: string;
  ChatType: "direct" | "group";
  MessageSid: string;
  Timestamp: number;
  MediaUrls?: string[];
}

// 去重键
type DedupeKey = string;

// 去重缓存
const dedupeCache = new LRUCache<DedupeKey, boolean>({
  max: 1000,
  ttl: 5 * 60 * 1000 // 5 分钟
});
```

---

## 5. 关键实现

### 5.1 实现步骤

#### 步骤 1: 定义渠道接口

```typescript
// src/channels/channel-def.ts
export interface Channel {
  id: string;
  name: string;
  start(config: ChannelConfig): Promise<void>;
  stop(): Promise<void>;
  sendMessage(params: SendMessageParams): Promise<void>;
  getStatus(): ChannelStatus;
  probe?(): Promise<ProbeResult>;
}
```

#### 步骤 2: 实现消息处理管道

```typescript
// src/channels/process-message.ts
export async function processMessage(
  rawMessage: RawMessage,
  cfg: MoltbotConfig
) {
  // 1. 解析消息
  const parsed = parseMessage(rawMessage);

  // 2. 路由到 Agent
  const route = resolveAgentRoute({
    cfg,
    channel: parsed.channel,
    accountId: parsed.accountId,
    peer: parsed.peer,
  });

  // 3. 去重检查
  const dedupeKey = computeDedupeKey(parsed);
  if (shouldSkipDuplicate(dedupeKey)) {
    return; // 跳过重复消息
  }

  // 4. 构建上下文
  const ctx = await finalizeInboundContext({
    ...parsed,
    sessionKey: route.sessionKey,
    agentId: route.agentId,
  });

  // 5. 分发处理
  await dispatchReplyFromConfig(ctx, cfg);
}
```

#### 步骤 3: 实现消息去重

```typescript
// src/auto-reply/reply/inbound-dedupe.ts
const dedupeCache = new LRUCache<string, boolean>({
  max: 1000,
  ttl: 5 * 60 * 1000
});

export function shouldSkipDuplicateInbound(
  dedupeKey: string
): boolean {
  if (dedupeCache.has(dedupeKey)) {
    return true; // 重复消息
  }

  dedupeCache.set(dedupeKey, true);
  return false;
}

function computeDedupeKey(msg: ParsedMessage): string {
  return `${msg.channel}:${msg.accountId}:${msg.peer.kind}:${msg.peer.id}:${msg.messageId}`;
}
```

#### 步骤 4: 实现上下文构建

```typescript
// src/auto-reply/reply/inbound-context.ts
export async function finalizeInboundContext(
  partial: PartialMsgContext,
  cfg: MoltbotConfig
): Promise<MsgContext> {
  // 1. 格式化信封
  const envelope = formatAgentEnvelope({
    provider: partial.provider,
    senderName: partial.senderName,
    rawBody: partial.rawBody,
  });

  // 2. 加载群组历史（如果是群组）
  let groupHistory = '';
  if (partial.chatType === 'group') {
    groupHistory = await loadGroupHistory(partial.groupId);
  }

  // 3. 构建完整上下文
  return {
    Body: envelope,
    BodyForAgent: `${groupHistory}${envelope}`,
    RawBody: partial.rawBody,
    SessionKey: partial.sessionKey,
    AgentId: partial.agentId,
    Provider: partial.provider,
    From: partial.from,
    To: partial.to,
    ChatType: partial.chatType,
    MessageSid: partial.messageId,
    Timestamp: Date.now(),
    MediaUrls: partial.mediaUrls,
  };
}
```

#### 步骤 5: 实现信封格式化

```typescript
// src/auto-reply/templating.ts
export function formatAgentEnvelope(params: {
  provider: string;
  senderName: string;
  rawBody: string;
}): string {
  const channelName = capitalize(params.provider);
  return `[${channelName}] ${params.senderName}: ${params.rawBody}`;
}
```

### 5.2 参考代码位置

| 功能 | Moltbot 代码位置 |
|------|-----------------|
| 渠道接口 | `src/channels/channel-def.ts` |
| 消息处理 | `src/web/auto-reply/monitor/process-message.ts` |
| 消息去重 | `src/auto-reply/reply/inbound-dedupe.ts` |
| 上下文构建 | `src/auto-reply/reply/inbound-context.ts` |
| 信封格式化 | `src/auto-reply/templating.ts` |

---

## 6. 验收标准

### 6.1 功能验收

#### 验收项 1: 消息接收和去重

**测试步骤**:
1. 发送相同消息两次
2. 验证只处理一次

**通过标准**:
- 第一次消息正常处理
- 第二次消息被跳过

#### 验收项 2: 上下文构建

**测试步骤**:
1. 发送测试消息
2. 验证 MsgContext 构建正确

**通过标准**:
- 信封格式正确
- Session Key 正确
- 所有字段完整

---

**文档完成** ✅
